<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | fsword's blog]]></title>
  <link href="http://fsword.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://fsword.github.com/"/>
  <updated>2013-08-27T21:37:03+08:00</updated>
  <id>http://fsword.github.com/</id>
  <author>
    <name><![CDATA[fsword]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby中的self]]></title>
    <link href="http://fsword.github.com/blog/2012/06/29/rubyzhong-de-self/"/>
    <updated>2012-06-29T09:38:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/06/29/rubyzhong-de-self</id>
    <content type="html"><![CDATA[<p>ruby-china.org 上有人问<a href="http://ruby-china.org/topics/4026">self的含义</a>，发篇帖子解释一下<br/>
ruby里面的class关键字和def关键字的作用其实是<strong>改变上下文</strong>，这个<code>self</code>就是被改变的<code>上下文</code>中最重要的一个，按照ruby语法，遇到这样的关键字，self的含义就会变化<br/>
* 在<code>class内部</code>，self代表的是<code>当前这个类本身</code><br/>
<code>ruby
$ cat a.rb
class A
  puts self
end
$ ruby a.rb
A
</code>
* 而通过<code>def</code>进入方法以后，（在方法内部写的）self指的是<code>这个方法的当前调用者</code><br/>
```ruby
$ cat a.rb
class A
  def x</p>

<pre><code>p self
</code></pre>

<p>  end
end
A.new.x
$ ruby a.rb</p>

<h1>&lt;A:0x00000002705fb0></h1>

<p>```
如上所示，这次打印出来的self是类A的一个实例而不是类A本身</p>

<p>这两个原则非常重要，现在我们看看方法前加self是什么意思<br/>
```ruby
$ cat a.rb
class A
  def self.x</p>

<pre><code>p self
</code></pre>

<p>  end
end
A.x
A.new.x
$ ruby a.rb
A
a.rb:7:in <code>&lt;main&gt;': undefined method</code>x' for #&lt;A:0x00000001a83f58> (NoMethodError)
```
显然，这个方法看起来像是我们常说的“类方法”而不是实例方法（这个例子中，实例方法x不存在，于是抛出了异常），我们通常这么理解——</p>

<blockquote><p>方法前的self在class内部，所以它表示类A，这样，x方法的调用者是<strong>类A自身</strong>（而不是它的实例），根据之前的原则，在def关键字内部，self表示的是这个方法的调用者，在这里就是类A自己</p></blockquote>

<p>最后补充一下——<br/>
* ruby中的类本身也是对象，所以所谓“类方法”是个不太准确的描述，所有的方法都是属于某个对象的，这里的self.x其实是类A（<strong>再次强调：是A自己而不是A的实例</strong>）的“专有方法”，更进一步的理解要结合对eigenclass这个概念的理解</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sinatra-contrib没有自动装载]]></title>
    <link href="http://fsword.github.com/blog/2012/05/09/sinatra-contribmei-you-zi-dong-zhuang-zai/"/>
    <updated>2012-05-09T18:53:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/05/09/sinatra-contribmei-you-zi-dong-zhuang-zai</id>
    <content type="html"><![CDATA[<p>最近写代码是基于sinatra的，遇到了一点小问题<br/>
在Gemfile中添加了sinatra和sinatra-contrib，但是实际使用中，sinatra-contrib没有被装入
```ruby</p>

<h1>Gemfile</h1>

<p>gem 'sinatra'
gem 'sinatra-contrib'
<code>
解决的办法是在启动脚本里面手工加上一行require
</code>
require "bundler"
Bundler.require(:default)
require 'sinatra/contrib'
<code>
但是这个方式有点土，其实如果换用新版的bundle就可以自动处理了
</code>
$ gem update bundle
Updating installed gems
Updating bundler
Fetching: bundler-1.1.3.gem (100%)</p>

<pre><code>Successfully installed bundler-1.1.3
Updating rubygems-bundler
Fetching: rubygems-bundler-0.9.2.gem (100%)
Building native extensions.  This could take a while...
Successfully installed rubygems-bundler-0.9.2
Gems updated: bundler, rubygems-bundler
</code></pre>

<p>```
需要说明的是，bundler1.1目前在网站上写的还是 coming soon，不过新功能还是值得尝试的<br/>
顺便附上 <a href="https://github.com/carlhuda/bundler/blob/master/CHANGELOG.md">bundler 的 changlog</a></p>
]]></content>
  </entry>
  
</feed>
