<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby, | fsword's blog]]></title>
  <link href="http://fsword.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://fsword.github.com/"/>
  <updated>2014-11-03T08:18:26+08:00</updated>
  <id>http://fsword.github.com/</id>
  <author>
    <name><![CDATA[fsword]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多级module避免使用双冒号]]></title>
    <link href="http://fsword.github.com/blog/2014/10/04/duo-ji-module-bi-mian-shi-yong-shuang-mou-hao/"/>
    <updated>2014-10-04T11:48:00+08:00</updated>
    <id>http://fsword.github.com/blog/2014/10/04/duo-ji-module-bi-mian-shi-yong-shuang-mou-hao</id>
    <content type="html"><![CDATA[<p>在多层模块中定义类或者模块一般有两种做法：
```ruby
module A
  module B</p>

<pre><code>class C
...
end
</code></pre>

<p>  end
end
```</p>

<p>和</p>

<p><code>ruby
module A::B
  class C
  ...
  end
end
</code></p>

<p>直观看，后者显然要简洁一些，所以我们常常使用这种写法，不过，其实后者更灵活。</p>

<p>这两种写法并不是等价的：</p>

<p>```ruby
module A
  module B</p>

<pre><code>Sth = "hello"
</code></pre>

<p>  end
end
module A
  module B</p>

<pre><code>module C
  class X
    def hello
      puts Sth
    end
  end
end
</code></pre>

<p>  end
end</p>

<p>A::B::C::X.new.hello
```</p>

<p>执行上述代码：
<code>
$ ruby sample.rb
hello
</code></p>

<p>改为双冒号：
```ruby
module A
  module B</p>

<pre><code>Sth = "hello"
</code></pre>

<p>  end
end
module A::B::C
  class X</p>

<pre><code>def hello
  puts Sth
end
</code></pre>

<p>  end
end</p>

<p>A::B::C::X.new.hello
```</p>

<p>再执行就会出错了
<code>``
$ ruby sample.rb
v.rb:9:in</code>hello': uninitialized constant A::B::C::X::Sth (NameError)</p>

<pre><code>from v.rb:15:in `&lt;main&gt;'
</code></pre>

<p>```</p>

<p>如果你感觉奇怪，说明对ruby的语法理解的还不充分。初学者常以为module和class这两个关键字是"<code>定义</code>一个类/模块"，但其实它们的意思是"<code>打开</code>一个类/模块"（正是这一特性让ruby具备了open class的能力），而对于<code>打开</code>这个概念，随之而来的自然是可以访问这个类/模块上下文的各种常量。</p>

<p>在前一种写法中，我们实际上是在<code>依次打开</code>模块A、B、C，因此X可以访问这些模块中的常量，而<code>module A::B::C</code>这种写法只是打开了<code>A::B::C</code>这个模块，于是X就不能访问 A::B 这个模块的常量了。</p>

<p>module中的常量，通常是一些模块级的共享对象和数据，因此，为了让我们的代码能够访问这些位置，写成层次module显然比使用双引号的代码更有灵活性。</p>
]]></content>
  </entry>
  
</feed>
