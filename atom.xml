<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[fsword's blog]]></title>
  <link href="http://fsword.github.com/atom.xml" rel="self"/>
  <link href="http://fsword.github.com/"/>
  <updated>2014-04-30T14:11:54+08:00</updated>
  <id>http://fsword.github.com/</id>
  <author>
    <name><![CDATA[fsword]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序员的洁癖]]></title>
    <link href="http://fsword.github.com/blog/2014/04/29/cheng-xu-yuan-de-ji-pi/"/>
    <updated>2014-04-29T12:47:00+08:00</updated>
    <id>http://fsword.github.com/blog/2014/04/29/cheng-xu-yuan-de-ji-pi</id>
    <content type="html"><![CDATA[<p>程序员这个群体里有一些人有代码洁癖，他们遇到一个烂东西往往不能忍受，一般认为，这对工作的推进是很不利的，因为有时候过于追求 do things right 会导致不能及时的 do right things 。</p>

<p>但是我却有些不同的想法，我们常常看到的情形其实不是洁癖太多而是太少，甚至对代码没有什么责任感，一些“很有执行力”的同事，其实是“大干快上”的路子，这样会让工作变成历史包袱。</p>

<p>当然，有洁癖的人确实会显得“执行力”不够，但是问题可能并不出在“因为洁癖要追求完美”，而是——能力确实就不够。</p>

<p>这么说有些残忍，不过以我自己的经历看，可能这才是真实情况。</p>

<p>我也是个有洁癖的人，干活一直不是很快。刚工作的时候别人的建议往往”别想太完美，做了再说“。现在工作很多年了，有些方面我开始熟悉甚至精通，由于经验积累，我在这些方面做事会比较快，这时遇到之前的朋友，他们会觉得我开始务实，不那么有洁癖了。</p>

<p>然而我的洁癖其实一直没变，变化的是工作能力。即使现在，如果遇到我不熟悉的领域，工作还是不够快。当然，这时其他人会觉得“你又太注意完美了”。</p>

<p>追求完美当然很好，这些人只是觉得过于注意完美会影响效率。逻辑确实没错，不过我们怎么判断这个度呢？有些我们一开始没有想好的东西会影响后续的很多工作，而有些东西计较太多却并没什么区别。是“吹毛求疵”还是“远见卓识”？如何判断？</p>

<p>说实话，我也没什么好办法，可能有点帮助的就是过往的经验了。编程是一个创造性的工作（如果只是重复劳动，那么复制即可，也就不需要coding了），不过通过抽象、类比这样的思维活动，我们能找到一些和过去的经验类似的模式，回想过去的经历，我们会认识到某些事情看来不重要，而某些则对后续工作影响深远，在这些经验的支持下，我们会选择把力气用在什么地方。</p>

<p>从这个角度看，你会发现一个现象，其实没有真正意义上“求全责备”的人，即使那些公认有洁癖的人，也不会在所有地方都吹毛求疵，他们只是在“什么东西更重要”这个问题上作出了与你不同的回答而已。</p>

<p>每个人的经历都不尽相同，因此基于经验产生的判断也不会完全一样，而团队需要交流的，正是这种不同的经验。由于每个人的思维都可能存在盲点和误区，大家沟通各自的旧有经验，发现值得重视的地方，就可以不断改进工作；另一方面，由于每个人都会有一些思维定势，因此交流和沟通都会带来冲突，解决冲突需要冷静细致的工作，甚至还要搭上时间成本。因此，民主的氛围有时会比较有助于团队成功，但有时又会带来很多的代价。在这方面没有标准答案，只能尽量的寻求平衡。</p>

<p>甚至经历也不是万能的，有过几年工作经历以后，很多人都会遇到被自己的旧知识“坑一下”的情况，似乎以前的教训现在也可以忽视，而以前的成功方法放到现在反倒是一剂毒药。这是“创造性”工作的本质决定的，抽象也好类比也罢，它一定需要丢弃一些不同，我们常说“旧观念需要更新，情况变了”，这里的情况就是那些被抛弃掉的、本以为不重要的东西。</p>

<p>上述话题要说完整可能需要很多篇幅，这里只想说明的软件开发是一件很难的事情。而正是因为软件开发如此之难，因此需要每个人都有一些“洁癖”，工作时需要更多的思考，而不只是完成任务。如果你因此而进展缓慢，无论是不是因为“洁癖”太多，努力提高能力和经验都是解决之道，慢慢的，你的工作会更熟练，效率得以提升，同时也更有经验去判断什么才是真正重要的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[比特币值多少钱？]]></title>
    <link href="http://fsword.github.com/blog/2014/04/06/how-much-about-btc/"/>
    <updated>2014-04-06T12:06:00+08:00</updated>
    <id>http://fsword.github.com/blog/2014/04/06/how-much-about-btc</id>
    <content type="html"><![CDATA[<p>「摘要：货币作为通用凭证，其价值是背后所背书的商品和服务，比特币的价值就由此决定。」</p>

<p>前段时间写了一篇文章讨论比特币，有同事提了一个问题：“比特币到底值多少钱？”，最近一个月，比特币的交易价从4260到2420（根据okcoin交易所价格）出现大幅度波动，让这个问题显得更现实了。</p>

<p>比特币值多少钱？讨论这个问题，其实还是要回归到货币的本身作用上去，我们先复习一下基本常识。</p>

<p>作为媒介，货币把以物易物的一次交易分割为两笔交易：第一次是用自己生产的商品或者服务交换得到货币，第二次是用货币交换自己需要的其它产品或者服务。因此，这两次交易可以在不同的时间和地点，为供需双方提供了方便。考察这个过程，可以看出，货币本质上是信用凭证——人们可以用它证明自己曾经对外提供过某种价值，并以此要求获取同等价值的其它商品或者服务。</p>

<pre><code>为了方便讨论，我们把商品和服务统称为商品，后文中提到的商品，如无特殊说明，指的既包括狭义的商品，也包括服务。
</code></pre>

<p>既然是基于价值的信用凭证，那么凭证的“价值”其实就是它背后所“代理”的商品的价值。简单来说，一枚比特币的价值仅取决于进行交换的两个人，以买一块匹萨为例，如果你愿意用一块匹萨换得一枚比特币，那么这枚比特币的价值就是一块匹萨的价值。</p>

<p>这看起来是废话，但很多有价值的结论往往会基于这种废话，正因为前提正确到了接近废话的地步，我们后面的结论才会可靠。</p>

<p>进一步考察上面买匹萨这个现象，我们考虑到每一枚比特币都是实质等同的，换句话说，每一次交易都是在为所有的比特币确定了一个价格，随着各种交易的不断进行，这个价格也在随时变化。这些看起来似乎没有什么规律，然而如果我们把视角切换到整个比特币市场，你会发现，基于上面的前提，我们可以为整个比特币市场建立一个对应关系：</p>

<blockquote><p>所有流通的比特币总价值 = 所有用比特币进行交易的商品总价值</p></blockquote>

<p>从某种角度看，上面这句话实际上是从宏观角度重复了刚才说的前提。在比特币交易市场上，无数的消费者用脚投票，在不断的界定比特币的价值。在这里，比特币的价值，就是比特币交易所的成交价。</p>

<p>“交易所的交易价就是比特币的价值”，肯定会有人感觉很荒谬，按照这种分析，岂不是可以假设任何一个商品可以具备任意高的价值了吗？</p>

<p>这话也对也不对。现代经济学（不是马克思那一套）认为交易就是双方界定价值的过程，只要有人愿意出价，那就是对这个商品进行了一次标价，而考虑到各类人想法不同，这个价值的确是”一切皆有可能“。但是，当无数的交易构成了市场时，情况又会从混乱趋向稳定，即使一两个人出于恶作剧的目的进行捣乱，众多的交易一旦展开，商品的价格还是会稳定下来，这就是所谓的市场价。</p>

<p>不过问题并没有结束，现在我们的理解是：比特币的价值等于现在的市场交易价，但这只是<code>现在</code>。而当人们在问“比特币值多少钱”的时候，他们真正想问的其实是<code>未来</code>——比特币<code>将</code>会值多少？</p>

<p>答案很简单，由于比特币作为货币是一种信用凭证，所以比特币市场中”输入”了多少商品，现有的比特币就“背书”了多少商品，相应的，未来有多少财富进入这个市场，那么比特币就会在将来值多少商品的价值。</p>

<p>需要说明的是，这个规律对进入比特币市场的其它货币也适用，因为虽然货币不等于商品本身，但是它们也是信用凭证，其它货币的进入实际上等价于它们“背书”的商品进入了比特币市场。</p>

<p>那么，这个价值会有多大呢？其实在2013年比特币暴涨的时候已经有人算过了，在一篇名为《<a href="http://zhiqiang.org/blog/finance/intrinsic-value-of-bitcoin.html">比特币的内在价值</a>》的博客中，作者写道——</p>

<ul>
<li>如果你认为比特币和黄金差不多，全球央行的黄金储备总价值大约12万亿美元，换算下来一枚比特币大约价值57万多美元。</li>
<li>如果你认为比特币能完全替代美元钞票，美元的M0大约9000亿美元，如果用2100万比特币代替的话，一枚比特币大约价值4.5万美元。</li>
<li>如果你认为比特币能够替代全球隐藏的「黑钱」，由于「黑钱」不好定义，我们用「消失不见」的美元钞票来代替。全球的黑钱大约有1万亿美元。假设都用比特币来持有，一枚比特币的价值大约为4.8万美元。</li>
</ul>


<p>事实上，这种计算方法就是基于比特币将会覆盖的商品市场规模来进行估计的，根据我们之前的逻辑，其实这个估计方法原则上是合理的，当然细节上需要修正。</p>

<hr />

<p>注： 这里的“细节”主要是需要考虑流通速度，考虑到费雪公式：</p>

<pre><code>P × Q = M × V （商品加权平均价 x 商品数量 = 货币数量 x 货币流通速度）
</code></pre>

<p>对于比特币来说，假定商品数量和价格不变，流通越快，需求量会越低。</p>

<blockquote><p>通俗来说，如果一张美元每天经过1次交换，而比特币会经过3次交换，那么需要的比特币仅有美元的三分之一。</p></blockquote>

<hr />

<p>这结果也许令人吃惊，甚至有人认为这些都是天方夜谭，是郁金香泡沫，他们说法币才是有价值的货币。其实不然，认为法币天然有价值，有可能会陷入一个循环论证的陷阱：首先再重复一遍我们之前的结论了——一种货币值多少钱，取决于通过这种货币作为信用凭证表示的商品价值总量和货币总量的除法商；然后考虑一下那些人的逻辑：因为法币有价值，所以应该会有很多人使用，而法币值多少钱，又归因于众人的使用——这不正是自我循环么？</p>

<p>这个循环论证的错误如此简单，所以有些人也知道没有说服力，所以他们找到了一种补救性解释——法币不只是普通货币，它背后有国家信用背书，因此它会更有价值。</p>

<p>这个打补丁的解释也有问题，因为国家信用并不是什么神秘力量，它只是信用相对更好，并不是无限责任，在一个较长期的时间范围上看，国家的货币信用其实是很不靠谱的，如果法币的价值在于国家信用，那么其优越性也不会比某个大公司发行一种货币更好，这也是《货币的非国家化》作者的思考基础——国家在本质上也是一个市场主体而已，因此法币没有特殊性（货币的信用到底是什么？这个问题深究一下也很有意思，后面有机会再说吧）。</p>

<p>既然我们不能用自我循环来证明什么，那么就回归到货币的价值上去，看看货币究竟是解决了什么问题。前面说过，货币是基于价值的信用凭证，那不妨讨论一下为什么需要这个凭证，我们也许就能明白货币这个凭证的价值。</p>

<p>不用过多解释就能想明白，货币这个凭证是为了让以物易物的交易分离出交换双方，使得双方可以独立进行，换句话说，货币是用来降低交易费用的。优币还是劣币？至少在流通能力上应该可以体现：</p>

<pre><code>法币的交易需要银行介入，转账及其复杂，成本高傲，费用也不低
比特币的交易可以独立完成，成本很低
</code></pre>

<p>不能随意制造导致贬值，这只是一个好货币的基本要求（当然，现存的各种货币连这个都很难达到），比特币在这点上只不过和黄金相同而已；而低成本、稳定可靠的交易费用，这才是比特币超越黄金（也包括纸黄金）的魅力所在，基于这个前提，比特币能够广泛用于一切电子交易，同时能降低跨国交易成本，这个市场如此之大，足以支撑比特币的价值走上更高的台阶。</p>

<p>[注：本文最近一次修改时，比特币按照 okcoin 的成交价已经跌到了 2700 RMB 以下，所以你可以把我这篇文章看作一个预言，一到两年后我们再回来看这篇文章吧]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么说比特币是货币？]]></title>
    <link href="http://fsword.github.com/blog/2014/03/16/btc-is-money/"/>
    <updated>2014-03-16T22:53:00+08:00</updated>
    <id>http://fsword.github.com/blog/2014/03/16/btc-is-money</id>
    <content type="html"><![CDATA[<p>「摘要：货币本质上是一种通用凭证，证明拥有某种用于交换的资源和服务。劣币还是良币就看是否很容易对这个凭证起到“替代”作用，比特币在这一点上可以完美的抵御“注水”行为，因此可以很好的充当交易凭证，成为实际上的货币」</p>

<p>和朋友聊比特币，常常会有人问：“中国政府、日本政府都宣称比特币不是货币，你凭什么说它是货币”，这个问题很有代表性，我们就来专门谈谈这个问题。</p>

<p>首先要问，政府是否能决定一个东西是货币呢？</p>

<p>很多人都知道，1948年下半年国民党政府所发行的金元券，这是政府公开要求的货币，然而结果如何？金元券很快变成废纸，反倒是当时并非代表官方的共产党政权发行的货币逐渐成为主流。可能有人认为这个和政权更迭有关，因为看起来也可以理解为是国民党政府的政治和军事失败导致了金元券的失败，但是这个理由不是很有力，因为国统区金元券被逐步抛弃的时候，上海这样的大城市还没有易手，民众也没有换用解放区政府发行的货币，而是采用了以物易物和黄金作为代替。</p>

<p>更典型的例子是西汉末年的王莽币，那是具有政府信用的货币，而且在“王莽谦恭下士”的一开始，并没有政权被推翻的担忧，然而政府的货币政策反而加速了经济的崩溃，也导致了货币和王莽政权自身的灭亡。</p>

<p>上述的例子其实是说明了一个一般性的观点——货币现象终究还是经济现象，它必然要经过市场的考验，而政府虽然可以规定什么是法币，但是其实不能决定什么是老百姓赖以生活的通用货币。</p>

<p>随心所欲的发行一个货币，政府做不到，那么，能不能随心所欲的打压一种货币呢？</p>

<p>这要分开看——如果你去纳税，肯定要用政府指定的法定货币，比如我，纳税当然是人民币，不过，我也有一些同事，手头的美金比较方便，他纳税还可以拿出美金来，临时兑换成人民币缴税，这些并不矛盾。所以，从纳税这个功能看，政府指定一种货币不等于排斥另一种货币。</p>

<p>从另一方面看，政府可以下禁令禁止持有或者交易某种物品的，比如，在1947年的上海，你拿着解放区政府的货币是不太安全的。在这个意义上，政府确实能够打压一种货币——但是，这种打压依然是有限的，想想黑市吧，这个隐藏的市场虽然无时无刻不受到各国政府的联合打压，然而依然在持续的运行。无论我们喜欢不喜欢，可以预想的将来它都不会消亡。</p>

<p>小结一下上面所说的内容吧，其实归根到底一句话，这是——“市场的力量”，经历过改革开放的人们，对这个概念应该是再熟悉不过了。好的货币被保留，不是因为政府支持，而是因为市场认可，坏的货币被淘汰，不是因为政府反对，关键还是市场的否定。</p>

<p>既然市场是关键，那么让我们回到货币本身，思考一下什么才是货币。</p>

<p>众所周知，人类使用的货币的过程是从贝壳到金属币（例如铜钱、银子和金条），再到纸币的。那么问题就来了，贝壳为什么会被淘汰？其它金属为什么没能成为通用货币？后来又怎么被一张小纸片所代替？</p>

<p>有人解释说：金属是有用的，而贝壳是无用的。这个解释很牵强，因为我们知道秦半两和汉代五铢钱都是铜币，而在那个年代，铁器正在以更坚牢锐利的特点慢慢走向生产生活的舞台中央，那么，更有用的铁为什么没有成为主要货币呢？</p>

<p>我们熟悉的黄金也是一个很好的例子，很多人认为黄金背后的价值来源于它“有用”，这其实是一个误解。黄金不像钻石那样有很好的工业用途，那灿烂的颜色在现代新材料面前也没有什么不可替代的优势，对现代人来说，黄金除了加工为艺术品，已经基本没有什么拿得出手的使用价值，而成为工艺品，其中一个很大原因还是因为它本身很贵，所以，甚至艺术品制造也不能成为黄金有用的理由。</p>

<p>有用并不是货币的关键属性，那么它的关键属性是什么呢？我想，至少应该有这么几条——易于切分、便于携带、不易被替代。</p>

<p>我们先说最简单的前两条：</p>

<p>一、易于切分：这个很容易理解，金属币正是在这一点上领先于贝壳等早期货币，现代纸币通过不同面值的组合，大致上也能达到这个要求。</p>

<p>二、便于携带：货币是用来交易的，因此是否便于携带就很重要了，金属币在这方面是劣于纸币的，所以现代社会的黄金大部分都在国家的央行金库中，而与纸币相比，电子货币是更为方便和易于携带的货币形态。</p>

<p>作为电子系统，比特币天然便于携带，同时它在设计上支持无限切分，所以在前两条上，它相比任何货币形态都不落下风，但是更大的关键在第三条，而第三条不但不易理解，甚至也不好描述——其实“替代”这个用词并不太准确，只是考虑了很久我也找不到更好的说法。不过我还可以举例来说明我的意思，一般来说，我所说的的“替代”有这么几种常见方式——</p>

<ul>
<li><p>伪钞：这是最容易理解的一种“替代”，由于大多数人不能分辨钞票的真伪，拿着一张制作精美的伪钞会和真钞票具有同样的购买效果，如果打击伪钞不力，那么伪钞就可以“替代”真钞</p></li>
<li><p>（政府）货币增发：根据法律，新印出来的货币和原来市场上的货币具有同样的法律效力，也就是说，新钱可以“替代”旧钱</p></li>
<li><p>（贵金属）发现新矿：例如地理大发现改变了黄金和白银在欧洲的总拥有量，大家都是金块，从美洲运回的和旧的是一样的，新黄金可以“替代”旧黄金</p></li>
</ul>


<p>上述情况虽然看似不同，但是对货币而言其效果却是相同的——钱不值钱了。</p>

<p>为什么要讨论“替代”，我们先来看看货币的价值。用户持有货币，目的是期望这玩意能够被换成自己需要的东西（也许是马上，也许是未来）。而对普通人来说，获取货币的方式是交换——俗称挣钱——纸币也好，黄金也罢，我们得到它依靠的是付出某种商品或者服务，比如我卖一个苹果能获得两块钱，这个行为背后是我的一次价值判断——一个苹果价值为一块钱。</p>

<p>货币其实是某种凭证，我们以此证明自己曾经付出过劳动，出让过货物，提供过帮助，接受这个货币实际上是在与这些劳动、货物、帮助背后蕴含的价值进行交换。而一个凭证，其本身最重要的特性是什么呢？那就是不可替代！</p>

<p>举个例子，我向别人借本书，同时写了个借条给对方，对我来说，这个借条是用纸做的（纸币）还是用铜做的（铜币）并不重要，重要的是我要根据这个借条还书，所以这个借条一定是“独一份”，如果谁都能自己写个纸条，然后让我把书交还给他，那可就糟糕了。</p>

<p>现在回到“替代”这个概念，无论是上面举的哪个例子，货币的总量都变多了——当初我借给你的书得到一张两块钱的借条，而现在有人直接开一下印钞机就打印出了我们无法分辨的借条，那谁还愿意把书借给你？</p>

<p>“替代”这个概念很重要，因为它是我们理解通胀现象的基础，简言之，如果我们能区别两个货币，那么它们不存在“替代”的可能，而是会形成汇率，除非我们规定一个不变的汇率，否则一种货币的通胀不会传递到另外一种货币。</p>

<p>很多名气很大（我不知道实际水平如何）的人也犯过这个错误，比如一些人喜欢的郎咸平先生，他曾在节目中提出过一个观点：“比特币总量虽然不变，但是我们可以创造出各种山寨币，种类的增加还是会通货膨胀”，这话说的简直就像个外行，因为山寨币并不能和比特币互相替代，欧盟统一了货币，也没见因此而通缩。</p>

<p>有人会有疑问，现实生活中，也有利用外国货币冲击一国经济的情况，如果不能“替代”就不会引入通胀，那么这种现象又是怎么回事呢？</p>

<p>很简单，增加货币种类不会直接导致通胀，但是外国货币可能会对应到一些资源，由于本来由本国法币对应的资源被改用外国货币对应，本国的货币就显得多余了，钱多货少，于是价格就下跌了。那么郎咸平说的对吗？还是不对，因为这种“货币竞争”是要看货币的强弱的，如果中国放开货币限制，允许美元长驱直入，可能会有一些资源改为由美元对应，但是如果是是越南盾进来，则不会有这样的现象，因为人们相信美元，不相信越南盾，所以根本就不会有什么资产使用越南盾对应。</p>

<p>无论这个货币使用什么方式衡量多寡（比如黄金按成色和重量，纸币按照面值等等），他被伪造就是一种被替代——因为在一定场合下，假钞是可以代替真钞票进行交易的，此时，真钞票就被“替代”了。</p>

<p>通货膨胀也是一种替代，所谓钞票，每一张之间应当是含义相同的，除了特别设计的不同面值，使用中应该是一样的，而如果增加钞票的发行量，虽然发行的是真钞票，但是对经济的危害和伪钞是一样的——都会使得原来付出代价获得的钞票变得不那么稀罕。</p>

<p>理解了替代的概念，我们再来看看现有的几种被当作货币的事物，拿它们来与比特币做一个对比吧。</p>

<ul>
<li><p>黄金：出现新的资源几乎不太可能，所以没有“替代”。但是另一方面，黄金可以“以次充好”，如果要避免被“替代”，我们还需要能够鉴定成色，这是使用它的一大麻烦。</p></li>
<li><p>各国法币：是否存在新的替代，完全由央行决定，因此是否存在“替代”，要看政府的财政政策。另外，根据纸币的制作工艺，不同的法币还有不同比例的伪钞在市面上流通，它们也是“替代”。</p></li>
<li><p>比特币：由算法决定没有人能增加真的货币数量，无可替代。同时，由于它本质上是向全世界公开整个帐簿，因此也无法伪造。</p></li>
</ul>


<p>本身就易于切分和携带，再加上没有发生替代的可能，比特币无疑是更有资格成为货币的。即使各国央行联合抵制，也只是延缓这一进程，因为它其实是适应市场的需要而生，而最终的选择是市场作出的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个bug的修改]]></title>
    <link href="http://fsword.github.com/blog/2013/08/27/yi-ge-bugde-xiu-gai/"/>
    <updated>2013-08-27T16:28:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/08/27/yi-ge-bugde-xiu-gai</id>
    <content type="html"><![CDATA[<p>下面是一段工作中编写的代码，为便于理解修改如下——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Order</span>
</span><span class='line'>  <span class="kp">attr_accessor</span> <span class="ss">:type</span><span class="p">,</span> <span class="ss">:sub_orders</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># 统计订单及其包含子订单的数量，按照订单类型归类</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">count_items</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="n">sub_orders</span><span class="o">.</span><span class="n">reduce</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="n">order</span><span class="o">|</span>
</span><span class='line'>      <span class="n">order</span><span class="o">.</span><span class="n">count_items</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
</span><span class='line'>        <span class="n">result</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">[</span><span class="n">key</span><span class="o">]||</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">value</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">result</span><span class="o">[</span><span class="n">type</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">[</span><span class="n">type</span><span class="o">]||</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">result</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>乍一看没问题，但是计算出来的数字始终不对，细看才发现问题，修改一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">count_items</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="n">sub_orders</span><span class="o">.</span><span class="n">reduce</span><span class="p">({})</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="n">order</span><span class="o">|</span>
</span><span class='line'>      <span class="n">order</span><span class="o">.</span><span class="n">count_items</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
</span><span class='line'>        <span class="n">result</span><span class="o">[</span><span class="n">key</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">[</span><span class="n">key</span><span class="o">]||</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">value</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>      <span class="n">result</span> <span class="c1">#添加这一行</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">result</span><span class="o">[</span><span class="n">type</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">[</span><span class="n">type</span><span class="o">]||</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">result</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>分析原因，是对reduce的使用不够细致：each和map容易和以前写java代码时的思维方式一致，所以不容易犯错；而reduce的返回值用于进一步迭代，这种做法以前用的较少，潜意识里还是将result和s看作是一个服务于循环的变量。</p>

<p>想明白以后再带着新的角度看这个代码，于是发现还可以简化，reduce操作的最大特点就是将初始值和结果纳入到计算框架中，这样可以减少很多重复劳动，最后改成这样</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">count_items</span>
</span><span class='line'>    <span class="n">sub_orders</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">})</span> <span class="k">do</span> <span class="o">|</span><span class="n">result</span><span class="p">,</span> <span class="n">order</span><span class="o">|</span>
</span><span class='line'>      <span class="n">order</span><span class="o">.</span><span class="n">count_items</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="o">|</span>
</span><span class='line'>        <span class="n">s</span><span class="o">.</span><span class="n">update</span> <span class="n">key</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">s</span><span class="o">[</span><span class="n">key</span><span class="o">]||</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">value</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实就两点：1. block参数的模式匹配；2. update的返回值就是当前对象</p>

<p>试验代码在 <a href="https://gist.github.com/fsword/6353526">这里</a> ，Be fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享笔记-服务设计]]></title>
    <link href="http://fsword.github.com/blog/2013/08/02/fen-xiang-bi-ji-fu-wu-she-ji/"/>
    <updated>2013-08-02T15:49:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/08/02/fen-xiang-bi-ji-fu-wu-she-ji</id>
    <content type="html"><![CDATA[<p>这是公司UI团队的分享，做一个简单的摘要</p>

<h3>服务体验的相关要素</h3>

<ul>
<li>空间</li>
<li>人</li>
<li>(周边)物体</li>
<li>界面（包括交互方式）</li>
<li>传播</li>
<li>衡量</li>
</ul>


<h3>服务体验分析</h3>

<ul>
<li>分解服务环节</li>
<li>对每一个服务环节进行分析，分析思路可以是——</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> -&gt; 参与体验者
</span><span class='line'>   -&gt; 提供的服务
</span><span class='line'>     -&gt; 体验感走势 
</span><span class='line'>       -&gt; 用户的担忧 
</span><span class='line'>         -&gt; 增加的服务</span></code></pre></td></tr></table></div></figure>


<h3>举例</h3>

<ul>
<li>拔牙的手势: 提供给用户明确的感情交流机会</li>
<li>51job -> linkedin：产品定位的变化</li>
</ul>


<h3>其它</h3>

<p>和客户沟通的时候需要有一定的方法，避免开放式的讨论</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单测与持续集成3-erlang例子]]></title>
    <link href="http://fsword.github.com/blog/2013/07/22/dan-ce-yu-chi-xu-ji-cheng-3-erlangli-zi/"/>
    <updated>2013-07-22T10:22:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/07/22/dan-ce-yu-chi-xu-ji-cheng-3-erlangli-zi</id>
    <content type="html"><![CDATA[<p>本篇是<a href="http://fsword.github.io/blog/2013/06/07/dan-yuan-ce-shi-bu-shi-chi-xu-ji-cheng-de-ji-chu-2-xiang-mu-zhong-de-li-zi/">这篇</a>的后续，很早就放进了草稿箱，但是我一直懒得修改好，真是典型的拖延症患者。</p>

<p>我自己在项目中使用erlang时间并不长，而且断断续续，充其量是个初学者。之所以用erlang举例子，是因为它比较有代表性。</p>

<p>学习erlang，OTP是个转折点，接触了gen_server等一系列模式以后，很自然就会感觉到其实一个erlang进程更像是一个对象——有标识符，内部保存状态、对外提供服务接口、可用的交互通过消息传递进行等等。</p>

<p>相应的，进行测试时的问题也很类似。人们在宣传erlang时常常说它由于状态不可变，所以可测性很好，然而如果以一个进程为测试对象来看，我们会遇到进程间协作的问题——这相当于java程序里面的对象间协作。</p>

<p>在apposs_agent项目中我就遇到了这类问题，例如，有三个模块之间的依赖关系如下：</p>

<pre><code>client -&gt; responder
       -&gt; ssh_executor
</code></pre>

<p>那么，这时模块client中怎么使用其它模块呢？下意识的，我们让这种依赖变得“可插入”，于是就有了类似这样的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="c">%% client.erl</span>
</span><span class='line'><span class="c">%% .....</span>
</span><span class='line'><span class="nf">init</span><span class="p">([</span><span class="nv">Responder_mod</span><span class="p">,</span> <span class="nv">Host</span><span class="p">,</span> <span class="nv">GetHostInfoFun</span><span class="p">])</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="c">%% ...</span>
</span><span class='line'>  <span class="nv">State</span> <span class="o">=</span> <span class="nl">#state</span><span class="p">{</span><span class="n">host</span> <span class="o">=</span> <span class="nv">Host</span><span class="p">,</span>
</span><span class='line'>                 <span class="n">get_host_info_fun</span><span class="o">=</span><span class="nv">GetHostInfoFun</span><span class="p">,</span>
</span><span class='line'>                 <span class="n">responder_mod</span> <span class="o">=</span> <span class="nv">Responder_mod</span><span class="p">,</span>
</span><span class='line'>                 <span class="n">cmds</span> <span class="o">=</span> <span class="nv">Cmds</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>  <span class="nn">gen_fsm</span><span class="p">:</span><span class="nf">send_all_state_event</span><span class="p">(</span><span class="o">?</span><span class="nv">SERVER</span><span class="p">(</span><span class="nv">Host</span><span class="p">),</span> <span class="n">reconnect</span><span class="p">),</span>
</span><span class='line'>  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="n">disconnected</span><span class="p">,</span> <span class="nv">State</span><span class="p">}.</span>
</span><span class='line'>
</span><span class='line'><span class="c">%% ......</span>
</span><span class='line'><span class="nf">normal</span><span class="p">(</span><span class="n">do_cmd</span><span class="p">,</span> <span class="nl">#state</span><span class="p">{</span><span class="n">host</span><span class="o">=</span><span class="nv">Host</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="nv">Cm</span><span class="p">,</span> <span class="n">cmds</span><span class="o">=</span><span class="p">[</span><span class="nv">Cmd</span><span class="p">|</span><span class="nv">T_cmds</span><span class="p">],</span> <span class="n">exec_mod</span><span class="o">=</span><span class="nv">ExecMod</span><span class="p">,</span> <span class="n">responder_mod</span><span class="o">=</span><span class="nv">RespMod</span><span class="p">}</span><span class="o">=</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nv">RespMod</span><span class="p">:</span><span class="nf">run_caller</span><span class="p">(</span><span class="n">client</span><span class="p">))(</span><span class="nv">Host</span><span class="p">,</span> <span class="nv">Cmd</span><span class="p">),</span>
</span><span class='line'>  <span class="nv">Handler</span> <span class="o">=</span> <span class="nv">ExecMod</span><span class="p">:</span><span class="nf">exec</span><span class="p">(</span><span class="nv">Cm</span><span class="p">,</span> <span class="nv">Cmd</span><span class="p">),</span>
</span><span class='line'>  <span class="p">{</span><span class="n">next_state</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nv">State</span><span class="nl">#state</span><span class="p">{</span><span class="n">current_cmd</span><span class="o">=</span><span class="nv">Cmd</span><span class="p">,</span> <span class="n">cmds</span><span class="o">=</span><span class="nv">T_cmds</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="nv">Handler</span><span class="p">}};</span>
</span><span class='line'><span class="c">%% ......</span>
</span></code></pre></td></tr></table></div></figure>


<p>在state中放入复杂的数据结构，其实就是为了让ExecMod和RespMod变得可以“配置”，还单独测试client而不用依赖其它模块。</p>

<p>然而这种设计的成本实在太高了，实际中，exec_mod和responder_mod并不会改变，这个目标属于over design。</p>

<p>那么为了可测性是否有必要这么做呢？有一段时间我也不是很确定。</p>

<p>从结构上来看，ssh_executor和responder属于下层模块，client是它们的用户，隔离下层模块运行上层模块意义不大。从某种角度看，软件开发很像搭积木，我们做好下层模块以后就不用“隔离”它们了，要测试，带上大家一起跑是很方便的做法。</p>

<p>想通了这一点，上述的代码就很简单了——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">init</span><span class="p">([</span><span class="nv">Host</span><span class="p">])</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="c">%% ...</span>
</span><span class='line'>  <span class="nv">State</span> <span class="o">=</span> <span class="nl">#state</span><span class="p">{</span><span class="n">host</span> <span class="o">=</span> <span class="nv">Host</span><span class="p">,</span>
</span><span class='line'>                 <span class="n">cmds</span> <span class="o">=</span> <span class="nv">Cmds</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>  <span class="nn">gen_fsm</span><span class="p">:</span><span class="nf">send_all_state_event</span><span class="p">(</span><span class="o">?</span><span class="nv">SERVER</span><span class="p">(</span><span class="nv">Host</span><span class="p">),</span> <span class="n">reconnect</span><span class="p">),</span>
</span><span class='line'>  <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="n">disconnected</span><span class="p">,</span> <span class="nv">State</span><span class="p">}.</span>
</span><span class='line'>
</span><span class='line'><span class="c">%% ......</span>
</span><span class='line'><span class="nf">normal</span><span class="p">(</span><span class="n">do_cmd</span><span class="p">,</span> <span class="nl">#state</span><span class="p">{</span><span class="n">host</span><span class="o">=</span><span class="nv">Host</span><span class="p">,</span> <span class="n">cm</span><span class="o">=</span><span class="nv">Cm</span><span class="p">,</span> <span class="n">cmds</span><span class="o">=</span><span class="p">[</span><span class="nv">Cmd</span><span class="p">|</span><span class="nv">T_cmds</span><span class="p">]}</span><span class="o">=</span><span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nn">responder</span><span class="p">:</span><span class="nf">run_caller</span><span class="p">(</span><span class="n">client</span><span class="p">))(</span><span class="nv">Host</span><span class="p">,</span> <span class="nv">Cmd</span><span class="p">),</span>
</span><span class='line'>  <span class="nv">Handler</span> <span class="o">=</span> <span class="nn">ssh_executor</span><span class="p">:</span><span class="nf">exec</span><span class="p">(</span><span class="nv">Cm</span><span class="p">,</span> <span class="nv">Cmd</span><span class="p">),</span>
</span><span class='line'>  <span class="p">{</span><span class="n">next_state</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nv">State</span><span class="nl">#state</span><span class="p">{</span><span class="n">current_cmd</span><span class="o">=</span><span class="nv">Cmd</span><span class="p">,</span> <span class="n">cmds</span><span class="o">=</span><span class="nv">T_cmds</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="nv">Handler</span><span class="p">}};</span>
</span><span class='line'><span class="c">%% ......</span>
</span></code></pre></td></tr></table></div></figure>


<p>显然，这样修改以后，不但代码量减少了，而且代码专注于表达业务逻辑，因而也更容易理解了，好的代码应该专注，而不是眉毛胡子一把抓，您说是不是？</p>

<p>有人会说，那我们难道就不要单元测试了么？不错，这正是我想说的，<code>单元测试的关注点应该是具有很高算法复杂度的逻辑单元，而不是复杂性都委托出去的业务模块</code>，对于后者，不做单元测试并不是罪过。</p>

<p>上述的想法也只是逻辑推演，为了更加确认，我和淘宝内部的一个erlang项目的同事做了一些了解——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="err">“</span><span class="n">hi</span><span class="err">，你们的代码写很多</span><span class="n">mock</span><span class="err">吗？“</span>
</span><span class='line'><span class="err">”写的不多“</span>
</span><span class='line'><span class="err">”那单元测试的时候怎么隔离呢？要在进程内部的状态里面保存关联模块么？”</span>
</span><span class='line'><span class="err">“不用，我们主要写集成测试”</span>
</span><span class='line'><span class="err">“集成测试会不会覆盖不到位？”</span>
</span><span class='line'><span class="err">“目前的功能以业务为主，逻辑不是很复杂，用集成测试就够了”</span>
</span></code></pre></td></tr></table></div></figure>


<p>同事的回答和我想的一样，不过这毕竟只是少数项目，我希望能有更多的案例，大家一起交流、讨论</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[require使用例子]]></title>
    <link href="http://fsword.github.com/blog/2013/06/18/requireshi-yong-li-zi/"/>
    <updated>2013-06-18T17:08:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/06/18/requireshi-yong-li-zi</id>
    <content type="html"><![CDATA[<p>常常有人搞不清楚ruby脚本怎么装载，其实ruby有一个$LOAD_PATH全局变量，相当于java的classpath，require就是从这里的目录中进行查找的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ls
</span><span class='line'>boot.rb
</span><span class='line'>$ irb
</span><span class='line'>irb(main):001:0&gt; require 'boot'
</span><span class='line'>LoadError: cannot load such file -- boot
</span><span class='line'>    from /home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
</span><span class='line'>    from /home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:36:in `require'
</span><span class='line'>    from (irb):1
</span><span class='line'>    from /home/john/.rvm/rubies/ruby-1.9.3-p392/bin/irb:13:in `&lt;main&gt;'
</span><span class='line'>irb(main):002:0&gt; puts $LOAD_PATH
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1/x86_64-linux
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby/1.9.1
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby/1.9.1/x86_64-linux
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/1.9.1
</span><span class='line'>/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/1.9.1/x86_64-linux
</span><span class='line'>=&gt; nil
</span><span class='line'>irb(main):003:0&gt; $LOAD_PATH &lt;&lt; '.'
</span><span class='line'>=&gt; ["/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby/1.9.1/x86_64-linux", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/site_ruby", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby/1.9.1", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby/1.9.1/x86_64-linux", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/vendor_ruby", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/1.9.1", "/home/john/.rvm/rubies/ruby-1.9.3-p392/lib/ruby/1.9.1/x86_64-linux", "."]
</span><span class='line'>irb(main):004:0&gt; require 'boot'
</span><span class='line'>=&gt; true</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单测与持续集成2-项目中的例子]]></title>
    <link href="http://fsword.github.com/blog/2013/06/07/dan-yuan-ce-shi-bu-shi-chi-xu-ji-cheng-de-ji-chu-2-xiang-mu-zhong-de-li-zi/"/>
    <updated>2013-06-07T19:27:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/06/07/dan-yuan-ce-shi-bu-shi-chi-xu-ji-cheng-de-ji-chu-2-xiang-mu-zhong-de-li-zi</id>
    <content type="html"><![CDATA[<p>(原来的标题太长，改短一些 :-) )</p>

<p>前一篇博客写完以后觉得有些空，这篇说说现实中的例子。</p>

<p>淘宝是java集散地，我们以java项目为例，下面是一个项目中的测试代码——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCreative</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">CreativeDO</span> <span class="n">creative</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CreativeDO</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span><span class="err">此处省略</span><span class="mi">11</span><span class="err">行</span><span class="n">set</span><span class="err">语句</span><span class="o">...</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">creativeId</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">creativeDAO</span><span class="o">.</span><span class="na">addCreative</span><span class="o">(</span><span class="n">creative</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">creativeId</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个test方法只是用了最基本的验证方式，显然这是用于确保基本功能——能够正确的添加记录，充其量只是用来验证和数据库相关的配置文件是否正确</p>

<p>我们继续看上层代码——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreativeServiceImpl</span> <span class="kd">implements</span> <span class="n">CreativeService</span><span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">ResultDTO</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">addCreative</span><span class="o">(</span><span class="n">CreativeDTO</span> <span class="n">creativeDTO</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>        <span class="n">creativeDAO</span><span class="o">.</span><span class="na">addCreative</span><span class="o">(</span><span class="k">do</span><span class="o">);</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个类有自己的测试保护，不过这次我们就不要看那些代码了，先用vim看看outline吧——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">|-</span>   <span class="kd">class</span>
</span><span class='line'><span class="err">||     </span><span class="nc">CreativeServiceTest</span>
</span><span class='line'><span class="o">|-</span>   <span class="n">field</span>
</span><span class='line'><span class="o">||</span>     <span class="n">creativeService</span> <span class="o">[</span><span class="n">CreativeServiceTest</span><span class="o">]</span>
</span><span class='line'><span class="o">||</span>     <span class="n">creativeDAO</span> <span class="o">[</span><span class="n">CreativeServiceTest</span><span class="o">]</span>
</span><span class='line'><span class="o">||</span>     <span class="o">...</span>
</span><span class='line'><span class="o">|-</span>   <span class="n">method</span>
</span><span class='line'><span class="o">||</span>     <span class="n">before</span> <span class="o">[</span><span class="n">CreativeServiceTest</span><span class="o">]</span>
</span><span class='line'><span class="o">||</span>     <span class="o">...</span><span class="err">此处省略</span><span class="mi">10</span><span class="err">个用于测试</span><span class="n">addCreative</span><span class="err">的用例</span><span class="o">...</span>
</span><span class='line'><span class="o">||</span>     <span class="n">addCreative</span> <span class="o">[</span><span class="n">CreativeServiceTest</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>显然，服务层方法有非常充分的测试保护，通过服务层调用，creativeDTO也间接得到了验证，其功能覆盖要远大于之前单独针对DAO的测试用例。</p>

<p>那么，我们为什么要写那个DTO的测试呢？不但费力（11行set，每一行都需要精心填入合理的数据），还用处不大。</p>

<p>出现这个现象一般有两个原因——<br/>
* 实践中，工程师有时是先写DAO再写上层模块，这样，写完DAO以后service还不存在，要验证是正确性就必须写DAO的test case。
* service的运行一般是依赖某些服务容器的，为它编写的test case相当于服务器外部的一个客户端，而这需要将service部署起来。</p>

<p>前一个原因还好办，很多java团队都意识到DAO和相邻的软件层之间存在某些重复性，因而可以用类似代码模板的方式一次性生成DAO、Service。这时，service和DAO是一起出现的，这样，我们就可以直接关心service了。</p>

<p>而后一个原因则是困难所在，因为在没有持续集成意识并建立持续集成机制的团队中，“部署应用”这件事是所有工作中相对靠后的一步，通常是开发时间过半以后才有第一次部署，而这时团队成员们已经重复的写了很多测试用例。</p>

<p>解决这个问题，只有引入持续集成，在系统一开始，我们就“一杆子捅到底”，从“白板应用”开始进行持续构建、部署，新代码和功能不断地交付，功能验证可以在适合的层次上进行，对上面的例子而言，我们直接写service测试，那么对DAO部分的验证就可以直接省略了。</p>

<p>这一篇说的是java的场景，但其实道理有共同性，下次我们讨论一下erlang项目中的测试</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单元测试不是持续集成的基础]]></title>
    <link href="http://fsword.github.com/blog/2013/05/25/dan-yuan-ce-shi-bu-shi-chi-xu-ji-cheng-de-ji-chu/"/>
    <updated>2013-05-25T22:25:00+08:00</updated>
    <id>http://fsword.github.com/blog/2013/05/25/dan-yuan-ce-shi-bu-shi-chi-xu-ji-cheng-de-ji-chu</id>
    <content type="html"><![CDATA[<p>很多人关注甚至想尝试持续集成，然而也有一些人担心团队缺乏基础——“我们连单元测试都做不好，做持续集成不太合适吧”。如果不会走就学跑，那确实容易摔跤。不过，单元测试和持续集成并不是走和跑的关系。</p>

<p>为避免误解，首先明确一下名词(虽然没有照抄书本，但是应该不会差太远吧)：</p>

<ul>
<li>单元测试：以验证某个代码单元的正确性为目标进行的自动化测试活动，“代码单元”通常是函数、方法或者是类，测试过程中，目标单元对外部的编译或者功能依赖由stub或者mock技术进行隔离。</li>
<li>持续集成：一种敏捷实践，重点是尽早进行系统的集成测试，它在狭义上包括部署自动化和测试自动化。“持续”一般被理解为不断的对研发变更进行整体验证，“集成”通常包括对分支的集成（因此一般推荐单分支开发）和在一定条件下对不同子系统或者模块进行的集成。</li>
</ul>


<p>可以看出，单元测试针对的目标是局部而非整体，而持续集成面对的是整体。按照“饭要一口一口吃”的老话，似乎应该先做单元测试。</p>

<p>然而单元测试并不是免费的。任何自动化测试都是基于测试目标的功能而实现，因此，测试目标的稳定性就变成了测试价值的一个重要因素——时常发生变化的代码，对其做自动化测试是不划算的。那么，单元测试所针对那些小粒度的类、方法和函数，它们变化剧烈吗？</p>

<p>这可能和软件系统的类型有关。例如，如果我们是在开发一个短信发送客户端，由于所遵循的SMGP协议本身是相对稳定的，网络相关的功能单元就是稳定的；然而，如果我们开发一个应用系统（比如各种大大小小的互联网应用），业务上的变化可能对下层的模型代码产生天翻覆地的影响。考虑到大部分的软件研发团队和研发工程师们所处理的都是基于数据库+web的应用系统，我们所遇到的场景很可能是后一种情况。</p>

<p>去年我所在的团队推进质量改进时我们就发现了这个规律，当时我们首先推进的就是单元测试，虽然我强调“自动化测试”而非单元测试，但是开发同事们都很自然把精力放到了单元测试上。在一段时间的热心实施以后，一些人开始出现不同的声音——“有些测试刚写好，业务就发生了变化，不得不完全抛弃，瞎耽误时间”。问题显然不是同事们不尽责，我们分析发现，因为单元测试用例过于关注细节，业务变化的情况下很难进行积累，再继续下去会出现“边际效益递减”的情况，而如果开始做持续集成方面的工作，则可以补充自动化的集成用例——它相对稳定。</p>

<p>除此之外，单元测试还有一个常见的问题：mock的代价。</p>

<p>几年前ThoughtWorks的李晓有过一篇<a href="http://blog.sina.com.cn/s/blog_700820800100n2oh.html">不要把Mock当作你的设计利器</a>，<a href="http://www.iteye.com/topic/21630">这里</a>还有gigix转述郭晓的观点——</p>

<pre><code>I did have some doubts about using Mocks when i was programming, similar 
reasons - too hard to refactory, too brittle. And i total agree with the 
three places to use it - external resources (I/O), UI, third party API.
</code></pre>

<p>也许有人觉得这里的观点有些“极端”（好像中国人对“极端”是比较敏感的 :-D ），然而我们在实际工作中很容易感受到上述文章和引论所说的痛点。这里存在两个方面的问题——</p>

<ul>
<li>对变化不友好：一旦我们进行了mock，就在事实上建立了对外部变化的“屏障”——每次发生变化时都有可能忘记了被mock掉的“结合点”，即使记得，也增加了重构的成本，时间一长，维护mock代码就变成了一件苦差事</li>
<li>推迟集成：有了mock以后，我们可以很容易就建立起自动化验证机制。但是错误往往在于疏忽——mock掉的那个东西，未来需要使用“真实的东西“再测一遍，这不止增加了测试成本，而且还会在前期给人以“系统没问题”的错觉</li>
</ul>


<p>顺便说一句，这些问题在stub中也是类似的，mock和stub还有一些差异，但是这里就不涉及了。</p>

<p>对于这些分析，<a href="http://weibo.com/luning12">路宁同学</a> 的一个简单易用的观点是：“不对自己开发的模块写mock”，这个很好理解，因为自己开发的模块可以直接用“真家伙”，那么“假李鬼”也就用不着了。</p>

<p>我们是否可以沿着这个思路继续推进呢？实际上，之所以要区分“自己的模块”，是因为“自己的模块”好合作（自己和自己当然好合作），那么在我们推进持续集成以后呢？</p>

<p>持续集成，表面上看是在做部署自动化和测试自动化。然而这个实践的一个重要价值是“弥合缺口”——通过持续的将版本控制系统的多个分支合并到一个分支上，避免了分之间的鸿沟越来越大；通过持续的将系统的各个部分完整的部署在一起进行自动化联调和系统测试，避免了子系统与子系统、模块与模块之间的衔接隔阂。</p>

<pre><code>前者好理解，后者一般容易被忽视，我们知道，某些语言特性和框架也试图解决这种系统和模块边界
的衔接问题，例如java的interface，它就是设计来建立系统间协作接口的。然而真实的世界很难用
interface这类技术进行约束，即使实现了同样的interface，我们也不确定边界两边都遵守共同的约
束，能让我们放心的只有联调和系统测试。
</code></pre>

<p>显然，在我们推进持续集成的工作并通过这个工作不断的“弥合缺口”以后，那些之前不得不mock掉的所谓“别人的模块”甚至“外部的子系统”也就不再变得遥不可及而难以合作了。于是，我们惊喜的发现——mock变得可以省略了，随着持续集成的推进，一些原来不得不编写的mock可以直接用“真家伙”代替，而原来所倚仗的单元测试用例也随之变成了集成用例、联调用例&#8230;&#8230;</p>

<p>所以，单元测试并不是集成测试的基础。实际上，往往是持续集成扩展了质量保障的手段和方式，并因此减弱了单元测试的压力，从此我们可以专注在必要的单元测试用例上了。</p>

<p>如果你的团队做单元测试不是很给力，可以先找找原因，如果不是大家的主观意愿问题，不妨和持续集成的工作一起推进吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成中的缺环-4]]></title>
    <link href="http://fsword.github.com/blog/2012/12/14/chi-xu-ji-cheng-zhong-de-que-huan-4/"/>
    <updated>2012-12-14T22:14:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/14/chi-xu-ji-cheng-zhong-de-que-huan-4</id>
    <content type="html"><![CDATA[<p>昨天我用了很罗嗦的语言解释了一个简单的 DSL 例子，这是为了方便讲述后面的内容，那个例子是典型的“麻雀虽小，五脏俱全”，回想起来，它至少包含了这么几样——</p>

<pre><code>* 一个 DSL 解释脚本(dsl.rb)
* 一个装载脚本(run.rb)
* 使用 DSL 编写的文件(myapp)
</code></pre>

<p>这么继续演化下去，我们就会得到一个比较详细的实现方案。</p>

<p>不过，考虑到复杂性的增加，我们现在应该考虑一点设计了，比如代码的层次和结构。</p>

<p>代码如何组织呢？这是一个脚本为中心的项目，因此我们决定不使用unix那种传统的/usr, /bin, /etc 方案，而是直接把所有代码都放在一个目录下，这样比较方便清理，不用专门的打包工具。</p>

<p>首先很容易想到，我们需要普通的 config 目录；其次，考虑到我们会引入很多 profile 文件，所以建立一个专门的profile目录似乎也是很必要的；另外，作为脚本性质的项目，一定要有明确的调用入口，我们建立一个 script 目录用于存放直接执行用的脚本。</p>

<p>接下来是 lib 目录，我们应该把代码分开，做好高內聚和低耦合（这个没忘吧，脚本也要注意这些原则哦），因此一开始会是这样——</p>

<p><img src="http://fsword.github.com/images/adsci_dirs_old.png" alt="目录结构" /></p>

<p>看起来不错，但是用代码稍一尝试就发现了一些问题，主要是lib目录。</p>

<ul>
<li>没有考虑到外部服务的耦合，我们使用的系统服务应该是松耦合在这个体系中的，比如虚拟机分配系统，在淘宝这样的环境中，虚拟机分配系统可能有多种方案，随着业务和组织结构的变化，我们有可能需要切换不同的分配系统。</li>
<li>应用专用的目录没有办法去落实，实际上，DSL的方案决定了我们不会为某个应用做特殊化，我们要做的是各种服务的组装。</li>
<li>与capistrano相比，profile的设计显然有些僵硬，后续可能需要调整，当然，这样演化出来的可能是一个工具包，但是目前也想不清楚，我们把决策延后，暂时先不管它。</li>
</ul>


<p>经过设计和编码的迭代，目前是这样的：</p>

<p><img src="http://fsword.github.com/images/adsci_dirs.png" alt="目录结构" /></p>

<p>这并不是最后的结论，大家知道，设计和开发往往是交替进行的。不过无论如何，现在可以接着前进了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成中的缺环-3]]></title>
    <link href="http://fsword.github.com/blog/2012/12/13/chi-xu-ji-cheng-zhong-de-que-huan-3/"/>
    <updated>2012-12-13T13:45:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/13/chi-xu-ji-cheng-zhong-de-que-huan-3</id>
    <content type="html"><![CDATA[<p>终于要讲到 DSL 了，其实这个话题我更加感兴趣一些，这也是ruby的强项 :-)</p>

<p>我们首先应该从用户角度出发，看看用户写出来的 dsl 应该是什么样子，例如像一个配置文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># -*- encoding : UTF-8 -*-</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 定义web server类型，可选值: apache, nginx, tengine</span>
</span><span class='line'><span class="c1"># web_server :apache</span>
</span><span class='line'><span class="n">web_server</span> <span class="ss">:apache</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 定义应用服务器类型，可选值: tomcat, jboss</span>
</span><span class='line'><span class="c1"># app_server :tomcat # option: jboss</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 申请数据库资源</span>
</span><span class='line'><span class="c1"># from: 有时需要从已有的数据库中复制数据，from参数用于指明来源的数据库名称</span>
</span><span class='line'><span class="n">db</span> <span class="ss">:from</span> <span class="o">=&gt;</span> <span class="s1">&#39;sample&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 设定源代码获取方式，目前仅支持git和svn两种</span>
</span><span class='line'><span class="n">source</span> <span class="ss">:svn</span> <span class="o">=&gt;</span> <span class="s1">&#39;http://svn.yourserver.com/branches/some_branch&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 设定安装包的来源，目前仅支持 rpm 包安装</span>
</span><span class='line'><span class="c1"># 注意：如果设定了安装包，adsci将跳过build环境，此时source设定不会生效</span>
</span><span class='line'><span class="n">pkg</span>   <span class="ss">:rpm</span> <span class="o">=&gt;</span> <span class="s1">&#39;http://yum.yourserver.com/your_package.rpm&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 设定 mock 服务，指定的服务将用 mock 支持</span>
</span><span class='line'><span class="n">mock</span> <span class="ss">:service</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;myservice.core.1.0.0&#39;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 设定所依赖的其它 profile ，需要在指定 profile 的服务/应用启动后再启动</span>
</span><span class='line'><span class="n">after</span> <span class="ss">:portal</span>  <span class="k">do</span>
</span><span class='line'>  <span class="c1"># 在指定的 profile （这个例子中是 portal 应用）中为当前节点添加 url rewrite 规则</span>
</span><span class='line'>  <span class="n">rewrite</span> <span class="ss">:for</span> <span class="o">=&gt;</span> <span class="ss">:me</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 设定依赖的其它 profile ，不考虑启动顺序</span>
</span><span class='line'><span class="n">after</span> <span class="ss">:portal</span>  <span class="k">do</span>
</span><span class='line'>  <span class="n">route</span> <span class="ss">:for</span> <span class="o">=&gt;</span> <span class="ss">:me</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>真正的 DSL 应该比这个更强大一些，不过从这样开始应该不错。</p>

<blockquote><p>硬广告：这个文件比较简单，唯一需要说明的是tengine，这是淘宝基于nginx扩展的一个开源项目，好事者可以看<a href="https://github.com/taobao/tengine">这里</a>。</p></blockquote>

<p>用户通过这种方式说明自己的应用应该是怎样部署和工作的，其它事情交给工具。</p>

<p>实现DSL最常见的做法就是把DSL语句变成一个函数，然后在定义函数的上下文中eval用户的脚本，比如一个最简单的语法<code>web_server :apache</code>，
可以这么写——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Dsl</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">web_server</span> <span class="nb">name</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;设定web server为</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='irb'><span class='line'><span class="go">1.9.3p327 :008 &gt; include Dsl</span>
</span><span class='line'><span class="go"> =&gt; Object </span>
</span><span class='line'><span class="go">1.9.3p327 :009 &gt; eval(&quot;web_server :nginx&quot;)</span>
</span><span class='line'><span class="go">设定web server为nginx</span>
</span><span class='line'><span class="go"> =&gt; nil </span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是最简单的配置项。<br/>
但是这样做有什么意义呢？我们可以这样修改一下 Dsl 的代码——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># -*- encoding : UTF-8 -*-</span>
</span><span class='line'><span class="c1"># 文件名 dsl.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Dsl</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">web_server</span> <span class="nb">name</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">name</span> <span class="o">==</span> <span class="ss">:apache</span>
</span><span class='line'>      <span class="sb">`sudo /etc/init.d/httpd start`</span>
</span><span class='line'>    <span class="k">elsif</span> <span class="nb">name</span> <span class="o">==</span> <span class="ss">:nginx</span>
</span><span class='line'>      <span class="sb">`sudo /etc/init.d/nginx start`</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s1">&#39;抱歉，目前不支持这种 web server&#39;</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;启动 </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样也把eval的内容存为文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># -*- encoding : UTF-8 -*-</span>
</span><span class='line'><span class="c1"># 文件名 myapp</span>
</span><span class='line'><span class="n">web_server</span> <span class="ss">:nginx</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后编写一个装载脚本</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># -*- encoding : UTF-8 -*-</span>
</span><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1"># 文件名 run.rb</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;./dsl&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="kp">include</span> <span class="no">Dsl</span>
</span><span class='line'><span class="nb">eval</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
执行一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">ruby</span> <span class="n">run</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="o">[</span><span class="n">sudo</span><span class="o">]</span> <span class="n">password</span> <span class="k">for</span> <span class="n">john</span><span class="p">:</span>
</span><span class='line'><span class="err">启动</span> <span class="n">nginx</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就完成了一个最简单的 dsl 样例，在这个样例中，我们通过一个关键词 <code>web_server</code> 驱动了逻辑</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成中的缺环-2]]></title>
    <link href="http://fsword.github.com/blog/2012/12/12/chi-xu-ji-cheng-zhong-de-que-huan-2/"/>
    <updated>2012-12-12T17:39:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/12/chi-xu-ji-cheng-zhong-de-que-huan-2</id>
    <content type="html"><![CDATA[<p>「接上篇」比较新旧两个图，可以发现，除了要做好多应用的部署自动化以外，还有一个问题需要我们考虑，那就是资源的自动分配。</p>

<p>常见的是数据库资源，由于我们过去一直依赖DBA分配数据库帐号，每次测试都是使用的同样的一个数据库，这样一来，开发人员想要测试就要申请自己的数据库资源，有新来的同学如果不知道，就会用源码中配好的那个数据库链接，如果这时有人在测试，那就悲剧了。而如果偶尔需要多个分支一起开发，情况就更加可怕。</p>

<p>解决这个问题的办法是资源隔离和动态分配。而且，这个做法不只限于数据库，几乎所有的基础设施都要这么做，你会发现这个环境似乎有些象“云”，好吧，虽然我不喜欢这个buzz word，但是沿着这个思路走下去，确实可以用到一些“云xx”的技术，我们只要拿来主义就可以了。</p>

<p>循着这个思路，我们搭建了一些支持动态分配资源的服务，这是后续工作的基础。为了能够方便的操控部署工作，我又把自己一直负责的easy commander（以前叫 AppOSS）也嫁接了过来，这样我们就得到了这些</p>

<p><img src="http://fsword.github.com/images/ci_deploy.png" alt="部署图" /></p>

<p>对单个应用而言，本来就有一些shell脚本（例如执行 maven 打包和启动停止服务器之类），所以我只要简单写一些ruby脚本负责协作，就让这个原型跑了起来，经过验证，可行。</p>

<p>接下来要做什么？我们现在仅仅用脚本驱动了起来，而ruby语言在我们这个团队中并不是公共知识，所以最好能够开发一些 DSL ，让大家简单的写一些“配置文件”，就能让自己关心的几个系统部署好。</p>

<p>如何实现这些DSL呢？明天接着说</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成中的缺环-1]]></title>
    <link href="http://fsword.github.com/blog/2012/12/12/chi-xu-ji-cheng-zhong-de-que-huan/"/>
    <updated>2012-12-12T17:11:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/12/chi-xu-ji-cheng-zhong-de-que-huan</id>
    <content type="html"><![CDATA[<p>我们通常说的持续集成，是指通过彻底的自动化手段，让软件在需求、设计、编码、测试这几个环节上自然流动，形成连续的迭代过程，这里的关键词是“持续”，基本技术手段就是“自动化”了</p>

<p>不过说起来容易做起来难，目前为止，很多公司和团队都在一定程度上做了一些努力，我们也是如此，不过在审视自己的工作时，发现有个环节似乎缺失了，这就是联调或者说系统集成。</p>

<p>从某种角度上看，软件开发的过程是将大功能拆成小任务，然后自底向上逐步累积的，如图</p>

<p><img src="http://fsword.github.com/images/software_layer.png" alt="software_layer" /></p>

<p>我们的测试实际上也是循着这个基本前提进行的。众所周知，越是底层的软件单元，越容易进行覆盖性测试，但代价是需要在边界上进行模拟，也许是mock，也许是simulator，而高层的测试可以避免在边界上的这种模拟成本，代价是不能完备的覆盖所有可能的逻辑分支。</p>

<p>通常的做法是结合，我们区分了单元测试、模块测试、集成测试几个层次。在单元测试中，我们使用mock技术尽可能覆盖逻辑分支；而在集成测试环节，更多的是关键路径和用户视角。</p>

<p>但是在我们这样的软件系统中，很少有独立工作的应用系统，大部分系统都是基于某种分布式架构进行协同的，常见的情况是这样的</p>

<p><img src="http://fsword.github.com/images/old_way.png" alt="old way" /></p>

<p>这样的结构对我们的质量工作提出了挑战，因为我们没有对应系统间协同测试的基础设施（至少我目前没有找到），这迫使我们尝试一条以前没有走过的路。</p>

<p>如前所述，基本的思路还是自动化，只不过现在我们要处理多个系统的自动部署和测试，相对而言，这种场景中的测试更接近验收测试，相对不是很复杂，所以关键就在部署上，我们希望实现这样的一张图</p>

<p><img src="http://fsword.github.com/images/new_way.png" alt="new way" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[erlang环境安装FAQ]]></title>
    <link href="http://fsword.github.com/blog/2012/12/09/erlanghuan-jing-an-zhuang-faq/"/>
    <updated>2012-12-09T15:46:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/09/erlanghuan-jing-an-zhuang-faq</id>
    <content type="html"><![CDATA[<h3>如何添加 wx 支持</h3>

<p>erlang的很多GUI工具都是基于wx库的，比如: reltool，但是缺省的ubuntu环境中的 erlang 包是没有wx支持的，常见错误是这样</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1&gt; reltool:start().
</span><span class='line'>
</span><span class='line'>=ERROR REPORT==== 9-Dec-2012::15:28:51 ===
</span><span class='line'>ERROR: Could not find 'wxe_driver.so' in: /home/john/software/otp/lib/erlang/lib/wx-0.99.1/priv
</span><span class='line'>** exception exit: {load_driver,"No driver found"}
</span><span class='line'>     in function  wxe_server:start/0 (wxe_server.erl, line 64)
</span><span class='line'>         in call from wx:new/1 (wx.erl, line 99)
</span><span class='line'>         in call from reltool_sys_win:do_init/1 (reltool_sys_win.erl, line 140)
</span><span class='line'>         in call from reltool_sys_win:init/1 (reltool_sys_win.erl, line 130)
</span><span class='line'>         in call from proc_lib:init_p_do_apply/3 (proc_lib.erl, line 227)</span></code></pre></td></tr></table></div></figure>


<p>有经验的人一般会尝试自己编译erlang环境，但可能会发现编译时找不到wx库。实际上，ubuntu环境一般确实会安装 libwxgtk2.8-dev 这个包，但是需要添加一个 link （参考<a href="http://wiki.wxwidgets.org/Installing_and_configuring_under_Ubuntu">官方说明</a>）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /usr/include
</span><span class='line'>sudo ln -sv wx-2.8/wx wx</span></code></pre></td></tr></table></div></figure>


<p>另外，提醒一下，你可以在 configure 阶段验证是否支持 wx ，方法是看是否有下面的输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checking for debug build of wxWidgets... checking for wx-config... /usr/bin/wx-config
</span><span class='line'>checking for wxWidgets version &gt;= 2.8.4 (--unicode --debug=yes)... no
</span><span class='line'>checking for standard build of wxWidgets... checking for wx-config... (cached) /usr/bin/wx-config
</span><span class='line'>checking for wxWidgets version &gt;= 2.8.4 (--unicode --debug=no)... yes (version 2.8.12)</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模块的使用]]></title>
    <link href="http://fsword.github.com/blog/2012/12/05/mo-kuai-de-shi-yong/"/>
    <updated>2012-12-05T22:23:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/12/05/mo-kuai-de-shi-yong</id>
    <content type="html"><![CDATA[<p>我们常常使用模块，一般是这样</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">X</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">hello</span><span class="p">;</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">world</span><span class="p">;</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用起来很简单</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">006</span> <span class="o">&gt;</span>   <span class="kp">include</span> <span class="n">X</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="no">Object</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">007</span> <span class="o">&gt;</span> <span class="n">hello</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，有时候我不想先要include一下才能使用，这是会遇到错误</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">006</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">hello</span>
</span><span class='line'><span class="no">NoMethodError</span><span class="p">:</span> <span class="n">undefined</span> <span class="nb">method</span> <span class="sb">`hello&#39; for X:Module</span>
</span><span class='line'><span class="sb">    from (irb):6</span>
</span><span class='line'><span class="sb">    from /home/john/.rvm/rubies/ruby-1.9.3-p327-falcon/bin/irb:16:in `</span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是因为使用 def 定义的方法都是 module 的实例方法，当然，就象可以在class里定义类方法一样，module也可以这么做</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">X</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">hello</span><span class="p">;</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">world</span><span class="p">;</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># in irb</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">007</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">hello</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于方法很多的 module ，我们可以少写几个<code>self.</code>，只要借助 extend 机制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">X</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="nb">self</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">hello</span><span class="p">;</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">world</span><span class="p">;</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># in irb</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">007</span> <span class="o">&gt;</span>   <span class="n">X</span><span class="o">.</span><span class="n">hello</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">00</span><span class="mi">8</span> <span class="o">&gt;</span> <span class="kp">include</span> <span class="n">X</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="no">Object</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">00</span><span class="mi">9</span> <span class="o">&gt;</span> <span class="n">hello</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 extend 的作用是把当前这个module extend出去，使实例方法同时承担类方法的职责，那么，如果我们不希望这些方法被include呢，今天看 I18n的代码，学了一招</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">X</span>
</span><span class='line'>  <span class="kp">extend</span> <span class="no">Module</span><span class="o">.</span><span class="n">new</span><span class="p">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">hello</span><span class="p">;</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">world</span><span class="p">;</span> <span class="s1">&#39;world&#39;</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于extend的不是当前module，而是一个匿名module，这块“领地”其它代码接触不到，所以其内部的方法不能被include，达到了我们的要求</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">00</span><span class="mi">8</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">hello</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="s2">&quot;hello&quot;</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">00</span><span class="mi">9</span> <span class="o">&gt;</span> <span class="kp">include</span> <span class="n">X</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="no">Object</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p327</span> <span class="p">:</span><span class="mo">010</span> <span class="o">&gt;</span> <span class="n">hello</span>
</span><span class='line'><span class="no">NameError</span><span class="p">:</span> <span class="n">undefined</span> <span class="n">local</span> <span class="n">variable</span> <span class="ow">or</span> <span class="nb">method</span> <span class="sb">`hello&#39; for main:Object</span>
</span><span class='line'><span class="sb">    from (irb):10</span>
</span><span class='line'><span class="sb">    from /home/john/.rvm/rubies/ruby-1.9.3-p327-falcon/bin/irb:16:in `</span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>灵活运用module，可以很好的提高代码的复用性，同时保护好必要的封装，have fun !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链式调用的代码怎么写]]></title>
    <link href="http://fsword.github.com/blog/2012/08/26/lian-shi-diao-yong-de-dai-ma-zen-yao-xie/"/>
    <updated>2012-08-26T13:55:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/08/26/lian-shi-diao-yong-de-dai-ma-zen-yao-xie</id>
    <content type="html"><![CDATA[<p>使用ruby，一个很有价值的地方就是发明了各种DSL，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">tags</span><span class="o">.</span><span class="n">delete_if</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">.</span><span class="n">nil?</span><span class="p">}</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">.</span><span class="n">sub</span><span class="sr"> /^!/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">delete_if</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">.</span><span class="n">empty?</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种风格通常被称为链式调用，优点是代码比较连贯，去掉了多余的局部变量和赋值语句，符合人类的思维习惯。</p>

<p>但是也有隐含的问题——代码可读性有时候会受影响，例如这里的例子中，对数组的变换包括三个步骤，如果看的不仔细，就可能会遗漏。</p>

<p>按照我自己的经验，一般会改成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">tags</span><span class="o">.</span>
</span><span class='line'>     <span class="n">delete_if</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:nil?</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>     <span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">.</span><span class="n">sub</span><span class="sr"> /^!/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">}</span><span class="o">.</span>
</span><span class='line'>     <span class="n">delete_if</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:empty?</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，每行都是一个独立单一的逻辑部分，可读性就有了保障。
问题并没有结束，链式调用的另外一个常见问题是对于故障的处理，使用者有时会搞不清楚到底在哪里出了错。</p>

<p>由于这种api一般会使用延迟计算的方式（延迟计算是个大的话题，请google），之前的环节仅仅是收集计算所需要的逻辑，真正出问题总是在最后，而那时的错误可以输出完整的计算条件，所以大部分情况下故障处理还不是很复杂。</p>

<p>但是如果有的api设计的不好或者出现了意料以外的问题，我们怎么办呢？</p>

<p>处理故障最常用的工具是日志，而链式调用不太好做的也就是日志，好在ruby的标准库提供了一个很好用的api——tap（很多人一开始看到这个函数，发现什么都不做，觉得很奇怪），我们看下面的例子</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">tags</span>                       <span class="o">.</span><span class="n">tap</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">&quot;origin size: </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>    <span class="p">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">delete_if</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:nil?</span><span class="p">)</span>     <span class="o">.</span><span class="n">tap</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">&quot;del nil    : </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>    <span class="p">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="o">.</span><span class="n">sub</span><span class="sr"> /^!/</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">tap</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">&quot;sub        : </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">delete_if</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:empty?</span><span class="p">)</span>   <span class="o">.</span><span class="n">tap</span><span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">&quot;del empty  : </span><span class="si">#{</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的代码，既方便了连贯的表达业务逻辑，又能在必要的时候输出需要的日志，基本上就比较靠谱了，顺便在说一句，我专门调整了代码的对齐并不是简单的为了好看，如果有一天你确定这段代码不再需要日志输出，那么使用很多编辑器都支持的列编辑功能就可以一次性删除掉日志了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth 2.0 and the Road to Hell 中文版]]></title>
    <link href="http://fsword.github.com/blog/2012/08/01/oauth-2-dot-0-and-the-road-to-hell-zhong-wen-ban/"/>
    <updated>2012-08-01T10:45:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/08/01/oauth-2-dot-0-and-the-road-to-hell-zhong-wen-ban</id>
    <content type="html"><![CDATA[<p>They say the road to hell is paved with good intentions. Well, that’s OAuth 2.0.
人们常说，通往地狱的路往往都是处于好心铺设的。我想 OAuth 2.0 就是这样。</p>

<p>Last month I reached the painful conclusion that I can no longer be associated with the OAuth 2.0 standard. I resigned my role as lead author and editor, withdraw my name from the specification, and left the working group. Removing my name from a document I have painstakingly labored over for three years and over two dozen drafts was not easy. Deciding to move on from an effort I have led for over five years was agonizing.</p>

<p>上个月我做了一个痛苦的决定，彻底和 OAuth 2.0 标准断绝关系。我辞去了首席作者和编辑，从文档中删除了我的名字，并且离开了工作组。从一份你辛勤工作了三年，拥有几十份草稿的文档上删除自己的名字并不容易，决定离开一个我领导了五年的项目十分的痛苦。</p>

<p>There wasn’t a single problem or incident I can point to in order to explain such an extreme move. This is a case of death by a thousand cuts, and as the work was winding down, I’ve found myself reflecting more and more on what we actually accomplished. At the end, I reached the conclusion that OAuth 2.0 is a bad protocol. WS-* bad. It is bad enough that I no longer want to be associated with it. It is the biggest professional disappointment of my career.</p>

<p>促成我做这个极端决定的并不是某一件事情，这是一次由无数次的伤害导致的死亡。随着工作接近尾声，我越来越意识到 OAuth 2.0 是非常糟糕的协议，就像 WS-* 那些协议一样的烂，烂到我不愿意跟它有任何牵扯。这是我职业生涯中的最大遗憾。</p>

<p>All the hard fought compromises on the mailing list, in meetings, in special design committees, and in back channels resulted in a specification that fails to deliver its two main goals – security and interoperability. In fact, one of the compromises was to rename it from a protocol to a framework, and another to add a disclaimer that warns that the specification is unlike to produce interoperable implementations.</p>

<p>在邮件列表、会议、还是专家委员内部，无数次争论的结果却是，这份标准并没有达到两个最重要的目标 - 安全和互操作性。实际上，有一个（各方达成的）妥协就是将这份规范从协议变成一个框架，而另外一个妥协则是在规范上添加了一个申明——声称这份规范不用于建立交互式的实现。</p>

<p>When compared with OAuth 1.0, the 2.0 specification is more complex, less interoperable, less useful, more incomplete, and most importantly, less secure.</p>

<p>和 OAuth 1.0 相比，2.0的标准更加的复杂，缺乏互操作性，不实用，不完整，最重要的是，不安全。</p>

<p>To be clear, OAuth 2.0 at the hand of a developer with deep understanding of web security will likely result is a secure implementation. However, at the hands of most developers – as has been the experience from the past two years – 2.0 is likely to produce insecure implementations.</p>

<p>更明确的说，OAuth 2.0 在一个对安全有深入理解的开发者手里会是不错的。但是在大部分开发者手中，2.0的标准将会导致明显不安全的结果。</p>

<h2>How did we get here? 我们是如何变成这样的？</h2>

<p>At the core of the problem is the strong and unbridgeable conflict between the web and the enterprise worlds. The OAuth working group at the IETF started with strong web presence. But as the work dragged on (and on) past its first year, those web folks left along with every member of the original 1.0 community. The group that was left was largely all enterprise… and me.</p>

<p>问题的核心来源于“web”和“企业级”这两个不同世界的强大而不可逾越的冲突。IETF的OAuth工作组开始时有很强的web感，然而随着第一年的工作一再拖延，来自OAuth 1.0社区的web力量一个接一个的离开，这个工作组逐渐变得只剩下了喜欢“企业级”的成员和&#8230;&#8230;我。</p>

<p>[翻译未完成，待续] <br/>
The web community was looking for a protocol very much in-line with 1.0, with small improvement in areas that proved lacking: simplifying signature, adding a light identity layer, addressing native applications, adding more flows to accommodate new client types, and improving security. The enterprise community was looking for a framework they can use with minimal changes to their existing systems, and for some, a new source of revenues through customization. To understand the depth of the divide – in an early meeting the web folks wanted a flow optimized for in-browser clients while the enterprise folks wanted a flow using SAML assertions.</p>

<p>The resulting specification is a designed-by-committee patchwork of compromises that serves mostly the enterprise. To be accurate, it doesn’t actually give the enterprise all of what they asked for directly, but it does provide for practically unlimited extensibility. It is this extensibility and required flexibility that destroyed the protocol. With very little effort, pretty much anything can be called OAuth 2.0 compliant.</p>

<h2>Under the Hood</h2>

<p>To understand the issues in 2.0, you need to understand the core architectural changes from 1.0:
* Unbounded tokens - In 1.0, the client has to present two sets of credentials on each protected resource request, the token credentials and the client credentials. In 2.0, the client credentials are no longer used. This means that tokens are no longer bound to any particular client type or instance. This has introduced limits on the usefulness of access tokens as a form of authentication and increased the likelihood of security issues.
* Bearer tokens  - 2.0 got rid of all signatures and cryptography at the protocol level. Instead it relies solely on TLS. This means that 2.0 tokens are inherently less secure as specified. Any improvement in token security requires additional specifications and as the current proposals demonstrate, the group is solely focused on enterprise use cases.
* Expiring tokens - 2.0 tokens can expire and must be refreshed. This is the most significant change for client developers from 1.0 as they now need to implement token state management. The reason for token expiration is to accommodate self-encoded tokens – encrypted tokens which can be authenticated by the server without a database look-up. Because such tokens are self-encoded, they cannot be revoked and therefore must be short-lived to reduce their exposure. Whatever is gained from the removal of the signature is lost twice in the introduction of the token state management requirement.
* Grant types - In 2.0, authorization grants are exchanged for access tokens. Grant is an abstract concept representing the end-user approval. It can be a code received after the user clicks ‘Approve’ on an access request, or the user’s actual username and password. The original idea behind grants was to enable multiple flows. 1.0 provides a single flow which aims to accommodate multiple client types. 2.0 adds significant amount of specialization for different client type.</p>

<h2>Indecision Making</h2>

<p>These changes are all manageable if put together in a well-defined protocol. But as has been the nature of this working group, no issue is too small to get stuck on or leave open for each implementation to decide. Here is a very short sample of the working group’s inability to agree:</p>

<ul>
<li>No required token type</li>
<li>No agreement on the goals of an HMAC-enabled token type</li>
<li>No requirement to implement token expiration</li>
<li>No guidance on token string size, or any value for that matter</li>
<li>No strict requirement for registration</li>
<li>Loose client type definition</li>
<li>Lack of clear client security properties</li>
<li>No required grant types</li>
<li>No guidance on the suitability or applicability of grant types</li>
<li>No useful support for native applications (but lots of lip service)</li>
<li>No required client authentication method</li>
<li>No limits on extensions</li>
</ul>


<p>On the other hand, 2.0 defines 4 new registries for extensions, along with additional extension points via URIs. The result is a flood of proposed extensions. But the real issues is that the working group could not define the real security properties of the protocol. This is clearly reflected in the security consideration section which is largely an exercise of hand waving. It is barely useful to security experts as a bullet point of things to pay attention to.</p>

<p>In fact, the working group has also produced a 70 pages document describing the 2.0 threat model which does attempt to provide additional information but suffers from the same fundamental problem: there isn’t an actual protocol to analyze.</p>

<h2>Reality</h2>

<p>In the real world, Facebook is still running on draft 12 from a year and a half ago, with absolutely no reason to update their implementation. After all, an updated 2.0 client written to work with Facebook’s implementation is unlikely to be useful with any other provider and vice-versa. OAuth 2.0 offers little to none code re-usability.</p>

<p>What 2.0 offers is a blueprint for an authorization protocol. As defined, it is largely useless and must be profiles into a working solution – and that is the enterprise way. The WS-* way. 2.0 provides a whole new frontier to sell consulting services and integration solutions.</p>

<p>The web does not need yet another security framework. It needs simple, well-defined, and narrowly suited protocols that will lead to improved security and increased interoperability. OAuth 2.0 fails to accomplish anything meaningful over the protocol it seeks to replace.</p>

<h2>To Upgrade or Not to Upgrade</h2>

<p>Over the past few months, many asked me if they should upgrade to 2.0 or which version of the protocol I recommend they implement. I don’t have a simple answer.</p>

<p>If you are currently using 1.0 successfully, ignore 2.0. It offers no real value over 1.0 (I’m guessing your client developers have already figured out 1.0 signatures by now).</p>

<p>If you are new to this space, and consider yourself a security expert, use 2.0 after careful examination of its features. If you are not an expert, either use 1.0 or copy the 2.0 implementation of a provider you trust to get it right (Facebook’s API documents are a good place to start). 2.0 is better for large scale, but if you are running a major operation, you probably have some security experts on site to figure it all out for you.</p>

<h2>Now What?</h2>

<p>I’m hoping someone will take 2.0 and produce a 10 page profile that’s useful for the vast majority of web providers, ignoring the enterprise. A 2.1 that’s really 1.5. But that’s not going to happen at the IETF. That community is all about enterprise use cases and if you look at their other efforts like OpenID Connect (which too was a super simple proposal turned into almost a dozen complex specifications), they are not capable of simple.</p>

<p>I think the OAuth brand is in decline. This framework will live for a while, and given the lack of alternatives, it will gain widespread adoption. But we are also likely to see major security failures in the next couple of years and the slow but steady devaluation of the brand. It will be another hated protocol you are stuck with.</p>

<p>At the same time, I am expecting multiple new communities to come up with something else that is more in the spirit of 1.0 than 2.0, and where one use case is covered extremely well. OAuth 1.0 was all about small web startups looking to solve a well-defined problem they needed to solve fast. I honestly don’t know what use cases OAuth 2.0 is trying to solve any more.</p>

<h2>Final Note</h2>

<p>This is a sad conclusion to a once promising community. OAuth was the poster child of small, quick, and useful standards, produced outside standards bodies without all the process and legal overhead.</p>

<p>Our standards making process is broken beyond repair. This outcome is the direct result of the nature of the IETF, and the particular personalities overseeing this work. To be clear, these are not bad or incompetent individuals. On the contrary – they are all very capable, bright, and otherwise pleasant. But most of them show up to serve their corporate overlords, and it’s practically impossible for the rest of us to compete.</p>

<p>Bringing OAuth to the IETF was a huge mistake. Not that the alternative (WRAP) would have been a better outcome, but at least it would have taken three less years to figure that out. I stuck around as long as I could stand it, to fight for what I thought was best for the web. I had nothing personally to gain from the decisions being made. At the end, one voice in opposition can slow things down, but can’t make a difference.</p>

<p>I failed.</p>

<p>We failed.<br/>
<a href="http://hueniverse.com/2012/07/oauth-2-0-and-the-road-to-hell/">link</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby中的self]]></title>
    <link href="http://fsword.github.com/blog/2012/06/29/rubyzhong-de-self/"/>
    <updated>2012-06-29T09:38:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/06/29/rubyzhong-de-self</id>
    <content type="html"><![CDATA[<p>ruby-china.org 上有人问<a href="http://ruby-china.org/topics/4026">self的含义</a>，发篇帖子解释一下<br/>
ruby里面的class关键字和def关键字的作用其实是<strong>改变上下文</strong>，这个<code>self</code>就是被改变的<code>上下文</code>中最重要的一个，按照ruby语法，遇到这样的关键字，self的含义就会变化<br/>
* 在<code>class内部</code>，self代表的是<code>当前这个类本身</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">cat</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="nb">self</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="err">$</span> <span class="n">ruby</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="n">A</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>而通过<code>def</code>进入方法以后，（在方法内部写的）self指的是<code>这个方法的当前调用者</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">cat</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">x</span>
</span><span class='line'>    <span class="nb">p</span> <span class="nb">self</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span>
</span><span class='line'><span class="err">$</span> <span class="n">ruby</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="c1">#&lt;A:0x00000002705fb0&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上所示，这次打印出来的self是类A的一个实例而不是类A本身</p>

<p>这两个原则非常重要，现在我们看看方法前加self是什么意思</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">cat</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">x</span>
</span><span class='line'>    <span class="nb">p</span> <span class="nb">self</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">x</span>
</span><span class='line'><span class="n">A</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span>
</span><span class='line'><span class="err">$</span> <span class="n">ruby</span> <span class="n">a</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="n">A</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">rb</span><span class="p">:</span><span class="mi">7</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;&#39;: undefined method `</span><span class="n">x</span><span class="err">&#39;</span> <span class="k">for</span> <span class="c1">#&lt;A:0x00000001a83f58&gt; (NoMethodError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>显然，这个方法看起来像是我们常说的“类方法”而不是实例方法（这个例子中，实例方法x不存在，于是抛出了异常），我们通常这么理解——</p>

<blockquote><p>方法前的self在class内部，所以它表示类A，这样，x方法的调用者是<strong>类A自身</strong>（而不是它的实例），根据之前的原则，在def关键字内部，self表示的是这个方法的调用者，在这里就是类A自己</p></blockquote>

<p>最后补充一下——<br/>
* ruby中的类本身也是对象，所以所谓“类方法”是个不太准确的描述，所有的方法都是属于某个对象的，这里的self.x其实是类A（<strong>再次强调：是A自己而不是A的实例</strong>）的“专有方法”，更进一步的理解要结合对eigenclass这个概念的理解</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何求素数(2)]]></title>
    <link href="http://fsword.github.com/blog/2012/06/10/ru-he-qiu-su-shu-2/"/>
    <updated>2012-06-10T17:30:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/06/10/ru-he-qiu-su-shu-2</id>
    <content type="html"><![CDATA[<p>前一篇我们给出了筛法求素数的基本代码，但是针对比较大的数据量，运算速度难以接受。我们观察到运算资源并不饱和，浪费了CPU。简单的改进方式是变为并行计算，用多线程提高本机并行能力，如果以后有网络，还可以分布到不同机器节点上。<br/>
要做到并行计算，首先要分析算法中哪些环节可以并行，哪些步骤要顺序执行。回头看筛法的计算过程，主要工作包括两个：选择除数和用除数过滤数列。选择除数是从小到大顺序进行，不能并行，而用除数过滤数列则是各自独立，所以能够并行。<br/>
我们并行的方式来变换原来的算法。大致思路如下——</p>

<pre><code>1. 生成待过滤的数列
2. 根据并行数目将数列均匀切分，得到若干子数列
3. 从小到大循环除数，对每一个除数
    3.1. 并行同时过滤上述多个子数列
    3.2. 过滤N的平方根后停止循环
4. 连接所有子数列，输出最后的结果
</code></pre>

<p>这么做有个问题，我们切分数列的目的是为了在过滤时充分利用并行能力，但是在若干次过滤后，子数列将陆续被过滤完毕，所以并行计算单元（线程、机器节点等）会逐渐无用，要避免这种情况，应该在每次遇到子数列过滤完毕的时候重新切分数列。<br/>
最后的代码应该是这样</p>

<div><script src='https://gist.github.com/2905122.js'></script>
<noscript><pre><code>def prime n

  full_list = (2..n).to_a
  prime_list = []
  stop_index = (n ** 0.5).floor
  last_prime = 2
  
  while(last_prime &lt; stop_index)
    workers = split_range(n-1,num){ |range| Worker.new(full_list(range)) }

    last_prime = sublists.first.reduce() do |sum, i|
      break i if i &gt; stop_index
      workers.each{|cell| worker.filter_by(i)}
      i
    end
    prime_list = prime_list.concat(workers.first.value)
    full_list = workers[1..-1].map(&amp;:value).flatten
  end
  prime_list.concat(full_list.flatten)
end

def split_range total_num, concurrent_num
  # 将传入的总数分解为若干个首尾相连的 range ，range 个数为 concurrent_num 
end

class Worker
  # 分配独立的并行计算单元（例如线程），然后对给定资源执行 map 函数
end</code></pre></noscript></div>


<p>执行结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby prime_benchmark.rb 
</span><span class='line'>    user     system      total        real
</span><span class='line'>    10000   0.050000    0.000000   0.050000 (  0.048889)
</span><span class='line'>    100000  0.650000    0.000000   0.650000 (  0.649779)
</span><span class='line'>    1000000 39.810000   0.050000  39.860000 ( 39.961506</span></code></pre></td></tr></table></div></figure>


<p>在我的4核机器上改进很明显。</p>

<p><code>注意：之前的代码还有一个遗留问题，被过滤掉的数字其实不用再来做除数，而现在这个版本因为要重新切分数列，所以有机会减少这个浪费，这也是速度明显提升的原因</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何求素数(1)]]></title>
    <link href="http://fsword.github.com/blog/2012/06/09/ru-he-qiu-su-shu/"/>
    <updated>2012-06-09T11:08:00+08:00</updated>
    <id>http://fsword.github.com/blog/2012/06/09/ru-he-qiu-su-shu</id>
    <content type="html"><![CDATA[<p>学习语言的过程是比较枯燥的，不过我们可以拿来做一些有趣的事情，在解决具体问题的过程中熟悉语言。<br/>
例如我们可以来练习一下这个问题</p>

<h3>找出小于N所有素数</h3>

<p>首先复习一下学校里的知识——</p>

<ul>
<li>素数（也称质数），指的是一类大于1的自然数，这些自然数有个特点，除了1和它自身，它们不能被其它的任何自然数整除。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>举例：  
</span><span class='line'>    4不是素数，因为它可以被2整除；  
</span><span class='line'>    11是素数，因为除了1和它自身，它不能被其它自然数整除；</span></code></pre></td></tr></table></div></figure>


<ul>
<li>判断一个数是否是素数，最直接的方法就是检查所有大于2小于它的自然数能否被它整除，更进一步，最大除数只要达到N的平方根就行了</li>
</ul>


<p>根据上述知识，我们可以找到问题的解决思路。方法如下：</p>

<pre><code>1. 将N以内的所有整数列出来
2. 标出序列中的第一个素数（比如：2），然后将后续中能够被这个素数整除的成员删除
3. 对新的序列重复执行上述步骤，循环进行，循环次数不大于N的平方根
</code></pre>

<blockquote><p>上述解法其实是这个问题最古老（可能也是最高效）的方法——“<a href="http://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">筛法</a>(<a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>)”，是由古希腊数学家埃拉托斯特尼发明的</p></blockquote>

<p>根据这些知识，我们可以写出ruby版的实现</p>

<div><script src='https://gist.github.com/2896832.js'></script>
<noscript><pre><code>def prime n
  list = (2..n).to_a
  (2...(n ** (0.5)).floor).each do |i|  list.delete_if{|e| e &gt; i &amp;&amp; e % i == 0} end
  list
end</code></pre></noscript></div>


<p>执行一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p194</span> <span class="p">:</span><span class="mo">00</span><span class="mi">8</span> <span class="o">&gt;</span> <span class="n">prime</span> <span class="mi">100</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">97</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>成功!<br/>
是不是很简单？但是且慢，算出来需要多久呢？要是几百万以内的素数，又需要多长时间呢？<br/>
写一段代码验证一下（我们计算结束后不输出，这是为了避免大量数据输出对IO的压力）</p>

<div><script src='https://gist.github.com/2899473.js'></script>
<noscript><pre><code>require &#39;./prime.rb&#39; # user defined function
require &#39;benchmark&#39;

Benchmark.bm do |x| 
  (4..6).each do |i|
     x.report(10**i){ prime(10**i).last }
  end
end</code></pre></noscript></div>


<p>执行结果（修改了一下格式）——</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ruby prime_benchmark.rb
</span><span class='line'>       user      system       total        real
</span><span class='line'>       10000     0.020000     0.000000   0.020000   <span class="o">(</span>  0.024682<span class="o">)</span>
</span><span class='line'>       100000    1.410000     0.010000   1.420000   <span class="o">(</span>  1.419806<span class="o">)</span>
</span><span class='line'>       1000000   245.320000   0.060000   245.380000 <span class="o">(</span>246.231597<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>从10万到100万，耗时增加了200倍!!! 检查load和CPU占用率，发现load不高，但是有一个cpu核心占用率100%，这说明cpu的计算能力没有得到平衡使用，这个问题我们下一阶段解决</p>
]]></content>
  </entry>
  
</feed>
